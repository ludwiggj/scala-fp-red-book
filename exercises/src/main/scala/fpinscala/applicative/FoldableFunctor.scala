package fpinscala.applicative

import fpinscala.monoids.Monoid

import scala.annotation.tailrec
import scala.language.higherKinds

// Exercise 12.15

// Answer, to your own satisfaction, the question of why it’s not possible for
// Foldable to extend Functor. Can you think of a Foldable that isn’t a functor?
object FoldableFunctor {

  trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
  }

  //noinspection NotImplementedCode
  trait Foldable[F[_]] extends Functor[F] {
    def foldRight[A, B](as: F[A])(z: B)(f: (A, B) => B): B

    def foldLeft[A, B](as: F[A])(z: B)(f: (B, A) => B): B

    def foldMap[A, B](as: F[A])(f: A => B)(mb: Monoid[B]): B

    def concatenate[A](as: F[A])(m: Monoid[A]): A

    override def map[A, B](as: F[A])(f: A => B): F[B] = ???
  }

  // It's because foldRight, foldLeft, and foldMap don't give us any way of constructing
  // a value of the foldable type. In order to map over a structure, you need the
  // ability to create a new structure (such as Nil and Cons in the case of a List).
  // Traverse is able to extend Functor precisely because a traversal preserves the
  // original structure.

  // An example of a Foldable that is not a functor:

  // This class conceptually represents a sequence of A values, generated by repeated function
  // application starting from some seed value. But can you see why it's not possible to
  // define map for this type?
  case class Iteration[A](a: A, f: A => A, n: Int) {
    def foldMap[B](g: A => B)(M: Monoid[B]): B = {
      def iterate(n: Int, b: B, aa: A): B =
        if (n <= 0) b else M.op(b, iterate(n - 1, g(aa), f(aa)))

      iterate(n, M.zero, a)
    }

    // Problem with map is that there's no way of creating a B
    def map[B](f: A => B): Iteration[B] = {
      Iteration[B](null.asInstanceOf[B], identity[B], n)
    }
  }
}